---
import data from '@/data/hitos.json';
import CardHitos from './CardHitos.astro';
---

<div
  class="flex w-full flex-col items-center justify-between gap-16 sm:w-[80%] lg:w-full lg:flex-row xl:w-[80%]"
  style="--gap: 1rem; --gap-md: 4.5rem; --gap-lg: 1.5rem;"
>
  {data.map((hito) => <CardHitos {...hito} />)}
</div>

<script>
  document.addEventListener('astro:page-load', () => {
    const esferas = document.querySelectorAll('.hito-esfera');
    const paths = document.querySelectorAll('.svg-hito');

    if (!paths.length) return;

    const observer = new IntersectionObserver(
      (entries, observer) => {
        setTimeout(() => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const path = entry.target;
              const index = Array.from(paths).indexOf(path);

              const delay = index * 1.3;
              const delayLinea = (delay + 0.8) * 1;
              /* @ts-ignore */
              path.style.setProperty('--delay', `${delay}s`);
              path.classList.add('animation-hito');
              path.setAttribute('stroke-width', '2');

              // animar línea del círculo solo si hay siguiente hito
              if (esferas[index] && index < esferas.length - 1) {
                // calcular ancho de la línea según distancia al siguiente círculo
                const siguiente = esferas[index + 1];
                const rect1 = esferas[index].getBoundingClientRect();
                const rect2 = siguiente.getBoundingClientRect();

                const distance = rect2.left - rect1.right;
                const distance2 = rect1.right - rect2.left;

                /* @ts-ignore */
                esferas[index].style.setProperty('--line-width', distance + 'px');
                /* @ts-ignore */
                esferas[index].style.setProperty('--line-height', distance2 + 'px');

                /* @ts-ignore */
                esferas[index].style.setProperty('--delay-linea', `${delayLinea}s`);

                esferas[index].classList.add('linea-animada');
              }

              observer.unobserve(entry.target);
            }
          });
        }, 800);
      },
      { threshold: 0.5 }
    );

    paths.forEach((path) => observer.observe(path));
  });
</script>
